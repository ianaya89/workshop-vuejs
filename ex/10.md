# 伙 Ciclo de Vida

Cada componente de Vue tiene su propio [ciclo de vida](https://vuejs.org/images/lifecycle.png). Esto quiere decir que desde el momento que se crea hasta que muere, cada instancia atraviesa ciertas etapas o momentos.

Gracias a los *hooks* de Vue, podemos establecer c贸digo que se ejecute a medida que nuestro componente vaya pasando por estas etapas. Los *hooks* son funciones (con nombres predeterminados) que se *setean* en el `vm`.

Estos son los *hooks* m谩s importantes en orden de ejecuci贸n (se ejecutan una sola vez):

1. `beforeCreate` ★ Se crea la instancia pero todav铆a no se inicializ贸 (no existe `data`, `methods`, etc.)
2. `created` ★ Instancia creada e inicializada (podemos acceder a `data`, `methods`, etc.)
3. `beforeMount` ★ El template esta compilado pero no est谩 montado en el DOM
4. `mounted` ★ El template est谩 compilado y montado en el DOM
5. `beforeDestroyed` ★ La instancia est谩 por ser destruida pero todav铆a es funcional
6. `destroyed` ★ La instancia fue destruida (no podemos acceder a `data`, `methods`, etc.)

Y tambi茅n tenemos estos que pueden ejecutarse N cantidad de veces:

1. `beforeUpdate` ★ Se actualiz贸 informaci贸n pero todav铆a no se aplicaron los cambios al DOM
2. `updated` ★ Se actualiz贸 informaci贸n y los cambios se aplicaron al DOM


## `created()`

Este es uno de los *hooks* m谩s comunes y utilizados. Sirve principalmente para poder realizar peticiones HTTP, *setear* data o determinar valores defaults (entre otras cosas).

Nosotros lo vamos a utilizar, para que al momento de crearse el componente `CoinList` podamos llamar al servicio de Coincap para obtener la lista de assets.

Para eso vamos a realizar lo siguiente:

1. El primer paso es importar el servicio de coincap dentro del componente. Al igual que hacemos con los componentes de vue, tambien utilizamos *ES Modules* para importar archivos `.js`. Dentro de la parte `<script>` del archivo `src/components/CoinList.vue` importamos el modulo.

```html
<!-- src/components/CoinList.vue -->
<script>
import { getAssets } from '@/services/coincap'

export default {
  name: 'CoinList'
}
</script>
```

> El `@` que precede a `/services` es un alias que nos permtie referenciar el directorio principal de codigo, es decir `.src/`. Es una gran ventaja de @vue/cli (y webpack), ya que no tenemos que lidiar con rutas relativas, sabemos que `@/...` siempre refiere ese directorio y no va a cambiar. Si bien no es obligatorio, recomiendo utilizarlo siempre que podamos.

2. Vamos tambien a agregar la funcion `data` con dos propidades: `assets` (array) y `isLoading` (boolean):

```html
<!-- src/components/CoinList.vue -->
<script>
import { getAssets } from '@/services/coincap'

export default {
  name: 'CoinList',

  data () {
    return {
      assets: [],
      isLoading: true
    }
  }
}
</script>
```

3. Ahora vamos a crear el *hook* `created()` en el componente y haremos una llamada a `getAssets()` dentro del mismo.

```html
<!-- src/components/CoinList.vue -->
<script>
import { getAssets } from '@/services/coincap'

export default {
  name: 'CoinList',

  data () {
    return {
      assets: [],
      isLoading: true
    }
  },

  created () {
    getAssets()
      .then(({ data }) => {
        this.assets = data
        this.isLoading = false
      })
  }
}
</script>
```

Si inspeccionamos la documentaci贸n de Coincap o usamos el utilodad *Network* de las herramientas de desarrollo, podemos ver que la lista de assets viene dentro de un objeto llamado `data`. Es por eso que cuando se resuelve la *promise* `getAssets()` asignamos el valor de data a la lista de assets (usando destructuring). Tambien cambiamos el valor de la propiedad `isLoading` a `false`.

> Usamos el metodo `.then()` luego de llamar a `getAssets()` ya este metodo internamente esta usando `fetch` el cual esta basado en *promises*.

> Es importante usar *arrow function* para manejar las promesas ya que necesitamos mantener el valor lexico del objeto `this`.

> Estamos utilizando destructuring en el parametro para obtener la propiedad data. Seria equivalente a hacer `res => this.assets = res.data`.

![build](../img/networking.gif)

1. Para terminar un poco el ejercicio y mostrar la informacion obtenida en la vista, vamos a agregar un poco de HTML y un poco de magia de Vue. Primero agregamos un elemento para indicar que el contenido esta cargando. Este elemento tiene un directiva `v-if`, por lo tanto se va mostrar si y solo si, `isLoading` es `true`.

```html
<!-- src/components/CoinList.vue -->
<template>
  <section tabindex="0">
    <p v-if="isLoading">Cargando...</p>
  </section>
</template>
```

5. Ahora vamos a crear una tabla que combinamos con una directiva `v-for` para representar cada uno de los assets obtenidos por la API. Al contrario del "Cargando...", la tabla solo se muestra cuando `isLoading` es `false`.

```html
<!-- src/components/CoinList.vue -->
<template>
  <section tabindex="0">
    <p v-if="isLoading">Cargando...</p>
    <table v-else>
      <thead>
        <tr>
          <th>Simbolo</th>
          <th>Nombre</th>
          <th>Precio</th>
        </tr>
      </thead>
      <tbody>
        <tr v-for="a in assets" :key="a.id">
          <td>{{ a.symbol }}</td>
          <td>{{ a.name }}</td>
          <td>$ {{ parseFloat(a.priceUsd).toFixed(2) }}</td>
        </tr>
      </tbody>
    </table>
  </section>
</template>
```

En la tabla vamos a mostrar solo 3 propiedades de cada asset: `symbol`, `name` y `priceUsd`. Por otro lado usamos el `id` como identificador univoco para `key` y ademas agregamos un poco JavaScript para formatear el valor de `priceUsd` y evitar un n煤mero muy largo `parseFloat(a.priceUsd).toFixed(2)`.

![build](../img/loading.gif)

> Todos los *hooks* se implementan de la misma manera, se agrega una funci贸n con el nombre del *hook* dentro del `vm` y se ejecuta el c贸digo que se requiera. Simplemente tengan en cuenta las limitaciones y caracter铆sticas de cada uno.

> Los componentes tienen una propiedad `name` en el cual podemos definir el nombre del componente. La propiedad es optativa pero es recomendable de usar ya que puede facilitarnos la tarea al momento de hacer *debug*. Recomiendo usarla siempre y colocarle el mismo nombre que tiene el archivo.

___

###  Extras

En una aplicaci贸n real, deberiamos manejar el posible error que pueda ocurrir cuando interactuamos con Coincap, para eso te invito a que experimentes un poco y muestres un mensaje de error cuando la interaccion con el servicio falle. Tenes que usar el metodo `catch` de la *promise* y con una propiedad nueva en `data` para saber cuando mostrar un mensaje de error al usuario.


###  [Soluci贸n](https://github.com/ianaya89/workshop-vuejs/blob/master/hints/11.md)

[](https://github.com/ianaya89/workshop-vuejs/blob/master/ex/9.md)  [](https://github.com/ianaya89/workshop-vuejs/blob/master/ex/11.md)
